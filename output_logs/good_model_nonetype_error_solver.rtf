{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \{\
	"name": "InvalidValueError",\
	"message": "Cannot emit InvalidNumber(None) in compiled representation\
The InvalidNumber was generated by:\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type",\
	"stack": "---------------------------------------------------------------------------\
InvalidValueError                         Traceback (most recent call last)\
Cell In[4], line 5\
      2 deep_reload(good_model_working)\
      4 # run model \
----> 5 problem = good_model_working.opt_model.Opt_Model(graph, model_sets)\
\
File ~/Desktop/good_model/toy_src/good_model_working/opt_model.py:26, in __init__(self, graph, sets, enable_logging)\
     24 # Check for non-empty graph and periods, then build\
     25 if self.graph and self.time_periods and self.sets:\
---> 26     self.model = pyomo.ConcreteModel()\
     27     self.build()\
     29     if enable_logging:\
\
File ~/Desktop/good_model/toy_src/good_model_working/opt_model.py:43, in build(self)\
     40 self.build_model()\
     41 self.timer.toc('Model built')\
---> 43 self.timer.toc('Model solving...')\
     44 self.solve_model()\
     45 self.timer.toc('Model solved')\
\
File ~/Desktop/good_model/toy_src/good_model_working/opt_model.py:237, in solve_model(self, solver_name)\
    235 def solve_model(self, solver_name=\\"appsi_highs\\"):\
--> 237     solver = pyomo.SolverFactory(solver_name)\
    238     solution = solver.solve(self.model, tee=True)\
    240     return solution\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/opt/base/solvers.py:597, in OptSolver.solve(self, *args, **kwds)\
    593 try:\
    594     # we're good to go.\
    595     initial_time = time.time()\
--> 597     self._presolve(*args, **kwds)\
    599     presolve_completion_time = time.time()\
    600     if self._report_timing:\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/solvers/plugins/solvers/CBCplugin.py:263, in CBCSHELL._presolve(self, *args, **kwds)\
    255             logger.warning(\
    256                 \\"warmstart_file points to a file on a drive \\"\
    257                 \\"different from the current working directory.  \\"\
    258                 \\"CBC is likely to (silently) ignore the warmstart.\\"\
    259             )\
    261 # let the base class handle any remaining keywords/actions.\
    262 # let the base class handle any remaining keywords/actions.\
--> 263 super(CBCSHELL, self)._presolve(*args, **kwds)\
    265 # NB: we must let the base class presolve run first so that the\
    266 # symbol_map is actually constructed!\
    268 if (len(args) > 0) and (not isinstance(args[0], str)):\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/opt/solver/shellcmd.py:224, in SystemCallSolver._presolve(self, *args, **kwds)\
    221 self._keepfiles = kwds.pop(\\"keepfiles\\", False)\
    222 self._define_signal_handlers = kwds.pop('use_signal_handling', None)\
--> 224 OptSolver._presolve(self, *args, **kwds)\
    226 #\
    227 # Verify that the input problems exists\
    228 #\
    229 for filename in self._problem_files:\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/opt/base/solvers.py:706, in OptSolver._presolve(self, *args, **kwds)\
    700 if self._problem_format:\
    701     write_start_time = time.time()\
    702     (\
    703         self._problem_files,\
    704         self._problem_format,\
    705         self._smap_id,\
--> 706     ) = self._convert_problem(\
    707         args, self._problem_format, self._valid_problem_formats, **kwds\
    708     )\
    709     total_time = time.time() - write_start_time\
    710     if self._report_timing:\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/opt/base/solvers.py:757, in OptSolver._convert_problem(self, args, problem_format, valid_problem_formats, **kwds)\
    756 def _convert_problem(self, args, problem_format, valid_problem_formats, **kwds):\
--> 757     return convert_problem(\
    758         args, problem_format, valid_problem_formats, self.has_capability, **kwds\
    759     )\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/opt/base/convert.py:99, in convert_problem(args, target_problem_type, valid_problem_types, has_capability, **kwds)\
     97                 tmpkw = kwds\
     98                 tmpkw['capabilities'] = has_capability\
---> 99                 problem_files, symbol_map = converter.apply(*tmp, **tmpkw)\
    100                 return problem_files, ptype, symbol_map\
    102 msg = 'No conversion possible.  Source problem type: %s.  Valid target types: %s'\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/solvers/plugins/converter/model.py:78, in PyomoMIPConverter.apply(self, *args, **kwds)\
     70         symbol_map_id = instance.write(\
     71             problem_filename,\
     72             format=ProblemFormat.cpxlp,\
   (...)\
     75             **io_options\
     76         )\
     77     else:\
---> 78         (problem_filename, symbol_map_id) = instance.write(\
     79             filename=problem_filename,\
     80             format=ProblemFormat.cpxlp,\
     81             solver_capability=capabilities,\
     82             io_options=io_options,\
     83         )\
     84     return (problem_filename,), symbol_map_id\
     85 else:\
     86     #\
     87     # I'm simply exposing a fatal issue with\
   (...)\
     90     # arguments that can be sent to the writer?\
     91     #\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/core/base/block.py:1991, in _BlockData.write(self, filename, format, solver_capability, io_options, int_marker)\
   1988     def solver_capability(x):\
   1989         return True\
-> 1991 (filename, smap) = problem_writer(self, filename, solver_capability, io_options)\
   1992 smap_id = id(smap)\
   1993 if not hasattr(self, 'solutions'):\
   1994     # This is a bit of a hack.  The write() method was moved\
   1995     # here from PyomoModel to support the solution of arbitrary\
   (...)\
   2000     # dependency (we only need it here because we store the\
   2001     # SymbolMap returned by the writer in the solutions).\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/repn/plugins/lp_writer.py:208, in LPWriter.__call__(self, model, filename, solver_capability, io_options)\
    205     io_options['allow_quadratic_constraint'] = qc\
    207 with open(filename, 'w', newline='') as FILE:\
--> 208     info = self.write(model, FILE, **io_options)\
    209 return filename, info.symbol_map\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/repn/plugins/lp_writer.py:241, in LPWriter.write(self, model, ostream, **options)\
    237 # Pause the GC, as the walker that generates the compiled LP\
    238 # representation generates (and disposes of) a large number of\
    239 # small objects.\
    240 with PauseGC():\
--> 241     return _LPWriter_impl(ostream, config).write(model)\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/repn/plugins/lp_writer.py:467, in _LPWriter_impl.write(self, model)\
    465     ostream.write(f'\\\
\{label\}:\\\
')\
    466     self.write_expression(ostream, repn, False)\
--> 467     ostream.write(f'= \{(lb - offset)!r\}\\\
')\
    468 else:\
    469     # We will need the constraint body twice.  Generate\
    470     # in a buffer so we only have to do that once.\
    471     buf = StringIO()\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/repn/util.py:187, in InvalidNumber.__repr__(self)\
    184 def __repr__(self):\
    185     # We want attempts to convert InvalidNumber to a string\
    186     # representation to raise a InvalidValueError.\
--> 187     self._error(f'Cannot emit \{str(self)\} in compiled representation')\
\
File ~/anaconda3/envs/p_main/lib/python3.12/site-packages/pyomo/repn/util.py:177, in InvalidNumber._error(self, msg)\
    175     msg += \\"\\\
The InvalidNumber was generated by:\\\
\\\\t\\"\
    176     msg += \\"\\\
\\\\t\\".join(causes)\
--> 177 raise InvalidValueError(msg)\
\
InvalidValueError: Cannot emit InvalidNumber(None) in compiled representation\
The InvalidNumber was generated by:\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type\
\\tNone (<class 'NoneType'>) is not a valid numeric type"\
\}}